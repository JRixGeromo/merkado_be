generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id               Int             @id @default(autoincrement())
  email            String?         @unique
  password         String?
  vendorProfile    VendorProfile?
  orders           Order[]
  addresses        Address[]
  sentMessages     Chat[]          @relation("SentMessages")
  receivedMessages Chat[]          @relation("ReceivedMessages")
  socialAccounts   SocialAccount[] // Relation to SocialAccount
  wishes           Wish[] // Relation to Wish model
  favorites        Favorite[] // Relation to Favorite model
  reactions        Reaction[] // Relation to Reaction model
}

model SocialAccount {
  id                Int    @id @default(autoincrement())
  provider          String // e.g., "google", "facebook"
  providerAccountId String // The unique ID provided by the social login provider (e.g., Google ID, Facebook ID)
  user              User   @relation(fields: [userId], references: [id])
  userId            Int // Links back to the User model
}

model VendorProfile {
  id       Int       @id @default(autoincrement())
  location String? // For Google Maps location
  products Product[] @relation("VendorProducts")
  user     User      @relation(fields: [userId], references: [id])
  userId   Int       @unique
}

model Product {
  id              Int             @id @default(autoincrement())
  name            String
  stock           Int             @default(0)
  price           Float
  salePrice       Float?
  longDescription String? // Add longDescription for detailed product info
  images          ProductImage[] // Relation to ProductImage model
  category        ProductCategory @relation(fields: [categoryId], references: [id])
  categoryId      Int
  vendor          VendorProfile   @relation("VendorProducts", fields: [vendorId], references: [id])
  vendorId        Int
  unit            UnitOfMeasure   @relation(fields: [unitId], references: [id])
  unitId          Int
  orders          OrderItem[] // Link to OrderItem model
  wishes          Wish[] // Relation to Wish model
  favorites       Favorite[] // Relation to Favorite model
  reactions       Reaction[] // Relation to Reaction model
}

model Wish {
  id        Int      @id @default(autoincrement())
  product   Product  @relation(fields: [productId], references: [id])
  productId Int
  user      User     @relation(fields: [userId], references: [id])
  userId    Int
  createdAt DateTime @default(now())
}

model Favorite {
  id        Int      @id @default(autoincrement())
  product   Product  @relation(fields: [productId], references: [id])
  productId Int
  user      User     @relation(fields: [userId], references: [id])
  userId    Int
  createdAt DateTime @default(now())
}

model Reaction {
  id        Int      @id @default(autoincrement())
  type      ReactionType
  product   Product  @relation(fields: [productId], references: [id])
  productId Int
  user      User     @relation(fields: [userId], references: [id])
  userId    Int
  createdAt DateTime @default(now())
}

enum ReactionType {
  LIKE
  DISLIKE
}

model Order {
  id          Int         @id @default(autoincrement())
  status      OrderStatus @default(PENDING)
  totalAmount Float // Total price of the order
  customer    User        @relation(fields: [userId], references: [id])
  userId      Int
  payment     Payment? // Add this to make the relation bidirectional
  orderItems  OrderItem[] // Relation to order items
}

model OrderItem {
  id          Int     @id @default(autoincrement())
  order       Order   @relation(fields: [orderId], references: [id])
  orderId     Int
  product     Product @relation(fields: [productId], references: [id])
  productId   Int
  quantity    Int     @default(1)
  priceAtTime Float // Price of the product at the time of purchase
}

model ProductImage {
  id        Int     @id @default(autoincrement())
  imageUrl  String // URL to the image in cloud storage or path if using local storage
  product   Product @relation(fields: [productId], references: [id])
  productId Int
}

model ProductCategory {
  id       Int       @id @default(autoincrement())
  name     String
  products Product[] // Add this reverse relation to the Product model
}

model UnitOfMeasure {
  id       Int       @id @default(autoincrement())
  name     String    @unique // e.g., "sack", "serve", "bundle"
  products Product[] // Relation to products using this unit
}

model Address {
  id         Int    @id @default(autoincrement())
  postalCode String
  user       User   @relation(fields: [userId], references: [id])
  userId     Int
}

model Chat {
  id          Int      @id @default(autoincrement())
  message     String
  sender      User     @relation("SentMessages", fields: [senderId], references: [id])
  senderId    Int
  recipient   User     @relation("ReceivedMessages", fields: [recipientId], references: [id])
  recipientId Int
  sentAt      DateTime @default(now())
}

model Payment {
  id            Int           @id @default(autoincrement())
  method        PaymentMethod
  amount        Float
  transactionId String
  order         Order         @relation(fields: [orderId], references: [id])
  orderId       Int           @unique // Mark orderId as unique for a one-to-one relation
  status        PaymentStatus @default(PENDING)
  createdAt     DateTime      @default(now())
}

enum OrderStatus {
  PENDING
  COMPLETED
  CANCELLED
}

enum PaymentMethod {
  GCASH
  CREDIT_CARD
  PAYPAL
}

enum PaymentStatus {
  PENDING
  COMPLETED
  FAILED
}
